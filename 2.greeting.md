## 2. Interactive greeting

В данном задании тебе необходимо вывести приветствие для юзера на экран. 
Приветствие будет зависеть от текущего времени суток:
- если время находится между 6 утра и 12(не включительно) дня, то: "Good morning!";
- если время находится между 12 дня и 6(не включительно) вечера, то "Good day!";
- если время находится между 6 вечера и 12(не включительно) ночи, то "Good evening";
- если время находится между 12 ночи и 6(не включительно) утра, то "Good night";

####Декомпозиция  задания:
- создать html-файл со структурой приветствия и стилизовать его
- найти элемент, внутри которого выводится текст приветствия
- определить текущее время в часах
- определить текущее время суток
- сгенерировать приветствие в зависимости от времени суток
- создать функцию showGreeting(), которая будет отображать приветствие внутри указанного элемента
- обеспечить обновление созданной функции

### Поиск элемента
Поиск элемента был рассмотрен в предыдущем задании.

p.s. `querySelector`

### Определение текущего времени
Для получения текущего времени мы можем воспользоваться функцией `showTime` из предыдущего задания, которая вызывается каждую секунду для отображения актуального времени.
Напиши эту функцию самостоятельно и внутри нее вызывай функцию `showGreeting`. Эта функция будет принимать текущий час, который можно получить при помощи методы .getHours() объекта Date.
```js
const date = new Date();
const hours = date.getHours();
console.log(hours);
```
Внутри функции `showGreeting`, вызовем функцию,  `getTimeOfDay` возвращающую время суток (`morning`, `day`, `evening`, `night`) в зависимости от текущего времени в часах и функцию `greetingTextContent`, которая будет принимать текущее время суток (`morning`, `day`, `evening`, `night`) и изменять приветствие в соответстии с требованиями.
Написать функцию `getTimeOfDay` можно разными способами: используя опретор if... else, или оператор switch, или создать массив с названиями времён суток и в зависимости от того, какое целое число получается при делении текущего времени суток на 6, возвращать соответствующий элемент массива.
Если сомневаетесь какой подход выбрать, отталкивайтесь от того, что преимущество у наиболее простых, лакончиных и понятных решений. При этом не стремитесь к преждевременной оптимизации: можно использовать любой подход, решающий поставленную задачу.
Функция  `textContent(timeOfDay)` тоже пишем сами и она будет создавать строку приветствия с полученным аргументом `timeOfDay`: 
```js
const greetingText = `Good ${timeOfDay}`;
```
И присваивает значение `greetingText` textContent свойству html-элемента с приветствием.

## Доп. задание
Пользователь может ввести свое имя в конце строки приветствия. Это имя сохраняется после перезагрузки страницы.

#### Пользователь может ввести своё имя
Если вы воспользовались предложенной вёрсткой, данное требование в ней уже выполняется, никаких дополнительных усилий для его реализации предпринимать не нужно.

В рамках работы над данным пунктом требований было бы полезно познакомиться с интересным и разнообразным элементом [&lt;input&gt;](https://developer.mozilla.org/ru/docs/Web/HTML/Element/Input), разобраться с особенностями получения и изменения его значения.

Элемент `<input>` имеет больше 20 разных типов. Каждый из них предназначен для решения определённой задачи. В приложении используется пожалуй наиболее распространённый `<input>` с типом текст: `type="text"`. Но есть и другие типы элемента `<input>`, никак не связанные с вводом текста. Например:
- `color` - палитра для выбора цвета;
- `file` - загрузка файлов;
- `radio` - кнопка-переключатель;
- `range` - ползунок для изменения значения.

Так как не все элементы `<input>` связаны с текстом, уже известное нам свойство `textContent` для элемента `<input>` не работает. Вместо него используется удобное свойство `input.value` при помощи которого можно получить и указать значение `<input>`.

#### При перезагрузке страницы приложения имя пользователя сохраняется
Для сохранения имени пользователя используем хранилище браузера - `local storage`.

Работа с `local storage` состоит из двух частей.
1) перед перезагрузкой или закрытием страницы (событие `beforeunload`) данные нужно сохранить
```js
function setLocalStorage() {
  localStorage.setItem('name', name.value);
}
window.addEventListener('beforeunload', setLocalStorage)
```
2) перед загрузкой страницы (событие `load`) данные нужно восстановить и отобразить
```js
function getLocalStorage() {
  if(localStorage.getItem('name')) {
    name.value = localStorage.getItem('name');
  }
}
window.addEventListener('load', getLocalStorage)
```
Пояснения к коду:
- `window` - объект окна браузера, с ним связана загрузка и перезагрузка страницы
- `addEventListener` - метод, который отлавливает событие элемента и выполняет переданную функцию
- `localStorage.setItem` - метод сохраняющий данные в `localStorage`. Два параметра метода: имя значения, которое сохраняется и само значение, которое сохраняется
- `localStorage.getItem` - метод получающий данные из `localStorage`. Параметр метода - имя, под которым сохраняется значение.

Чтобы увидеть сохранённые в браузере данные `localStorage`, на странице приложения нажмите клавишу F12, на панели `devTools` вверху выберите пункт `Application`, на боковой панели пункт `Local Storage` и ссылку на страницу приложения.

Обратите внимание: данные в `localStorage` сохраняются в текстовом формате, например, вместо `true`, `false`, `localStorage` вернёт `"true"` и `"false"`.


### Демо для примера: 
- https://momentum-2021q3.netlify.app/
