# Audio player


В данном задании необходимо создать и добавить на страницу аудио плеер подобного или какого-либо иного дизайна:

<img width="403" alt="Screenshot 2022-10-06 at 08 29 24" src="https://user-images.githubusercontent.com/70028254/194221990-e9de305b-22f0-42a4-bc18-be88eec0b00f.png">

Плеер состоит из:
- картинки/фотографии альбома, песни, мелодии или какого-либо связанной с тематикой мелодии или исполнителя фото. Фото рассполагается в верхней части плеера и занимает всю его ширину и высоту равную ширине;
- ниже картинки рассполагается панель с именем исполнителя и названием композиции. Название композиции имеет больший размер шрифта, чем имя исполнителя.
- права от панели с названием песни и именем исполнителя рассполагается кнопка `play` вида ▶. При нажатии на кнопку `play` начинает играть мелодия. В свою очередь после этого, преобразуется в кнопку `pause` с символом ⏸. При нажатии на `pause` воспроизведение композиции останавливается и кнопка опять принимает вид `play`. При нажатии на `play` в этот раз, композиция воспроизводится с места где была остановлена;
- ниже рассполагается дорожка трека, а над ней слева - текущее время воспроизведения композиции, справа - полное время композиции. Дорожка так же визуально показывает сколько воспроизвелось, а сколько осталось;
- ниже рассполагается кнопка громкости, которая состоит из иконки динамика и ползунка для регулирования громкости. При нажатии на иконку динамика - звук отключается и иконка принимает вид зачеркнутого динамика. При повторном нажатии иконка возращается к первоначальному виду, а громкость становится равной такой же как перед отключением. Ползунок регулировки громкости позволяет изменять громкость в пределах 0 - 100. 

### Рекомендации по выполнению

‼ Писать js-код плеера будем в отдельном js-файле, назовем его `player.js` (html остается тем же). Так как плеер по сути своей является независимым от всего приложения компонентом, то лучше выделять всю его логику в отдельном файле, называемом модулем. Таким образом, мы создаем более чистую кодовую базу, где каждая сущность выделена в отдельный независимый модуль и позже все эти модули могут быть использованы в разных местах. Таким образом все что касается плеера у тебя будет храниться отдельно и никакой другой код не будет тебя путать и отвлекать от работы с плеером.
Так же для плеера можно создать и новый ccs-файл.

##### Перво на перво, необходимо создать html-верстку плеера в html-файле.
##### Создать, если нет, папку для хранения картинок и музыки `assets`, в ней создать папки `sounds` и `pictures`. Поместить в `sounds` композицию в mp3-формате, а в `pictures` картинку, соответсвтующую это композиции. Переименую эти файлы, чтоб было удобно к ним обращаться.

#### Немного теории: Работа с аудио в html

С появлением HTML5 добавление аудиоплеера на страницу превратилось в рядовую задачу. Для этого достаточно в html-файл добавить код плеера, и в атрибуте `src` указать ссылку на аудио-файл.
```html
<audio src="" controls></audio>
```
[Пример 1 на codepen](https://codepen.io/irinainina/pen/poerqar)

Внешний вид встроенного в браузер аудиоплеера в разных браузерах выглядит немного по-разному и очень плохо стилизуется. Если нужно создать плеер с определённым дизайном, в приведённом выше коде необходимо убрать атрибут `controls`, который отвечает за отображение плеера и написать js-код для его проигрывания:
```js
const audio = document.querySelector('audio');
function playAudio() {
  audio.currentTime = 0;
  audio.play();
}
function pauseAudio() {
  audio.pause();
}
```
[Пример 2 на codepen](https://codepen.io/irinainina/pen/RwoKVBW)

Функции `playAudio()` и `pauseAudio()` достаточно простые. Первая запускает проигрывание плеера используя метод `play()`, вторая - останавливает проигрывание, используя метод `pause()`. Строка `audio.currentTime = 0` указывает, что аудиотрек при каждом запуске функции `playAudio()` будет проигрываться с начала.

Есть возможность создать плеер средствами JavaScript(‼предпочтительный способ в данном задании‼). Причем даже совсем не надо добавлять тег `audio` в html-файл. Добавление возможности слышать и воспроизводить звуки на странице происходит из-за создания экземпляра js-класса `new Audio()` :
```js
const audio = new Audio();
function playAudio() {
  audio.src = // ссылка на аудио-файл;
  audio.currentTime = 0;
  audio.play();
}
```
[Пример 3 на codepen](https://codepen.io/irinainina/pen/dyvzrNV)

#### Вернемся к практике
У нас есть `player.js` файл где мы будем писать код для плеера.
И так, найдем необходимые на первом этапе html-элементы при помощи `document.querySelector`. Необходимые элементы - это **картинка** и **кнопка play/pause**.
Положим их в константы `soundImage` и `playButton`.
```js
const soundImage = document.querySelector('.sound_image');
const playButton = document.querySelector('.play_button');
```
Далее создаем браузерный внутренний объект аудио, который имеет методы для воспроизведения и остановки аудиозаписей.
```js
const audio = new Audio();
```
Теперь переменная `audio` содержит сслыку на некий внутренний браузерный объект плеера, невидимый на странице браузера, с которым мы можем работать.
Далее, скажем этому объекту `audio` что нужно воспроизводить и заодно отобразим картинку для этой мелодии:
```js
audio.src = 'здесь должны быть ссылка на мелодию, которая находится в папке `assets/sounds/`';
soundImage.src = 'здесь должны быть ссылка на картинку, которая находится в папке `assets/pictures/`';
```

Теперь, нам надо воспроизвести мелодию. Согласно требованиям, при нажатии на кнопку `play` композиция должна воспроизвестись, а сама кнопка преобразоваться в кнопку `pause`.
В первую очередь нам понадобиться глобальная переменная, которая будет флагом и назовем ее `isPlay`. Смысл этой переменной в том, чтоб хранить в ней состояние нашего аудиоплеера - играет или на паузе.
Флаги принмают как правило только булевые значения: true или false. Т.к. изначально наш плеер не воспроизводит композицию, то флаг будет иметь значение `false`.
```js
let isPlay = false
```
Далее переходим к логике воспроизведения. Мелодия должны воспроизводиться, когда происходит нажатие на кнопку `play`. Навесим листенер на эту кнопку:
```js
playButton.addEventListener('click', playPauseSound)
```
`playPauseSound` - это функция, которая будет заниматься воспроизведением и постановкой аудио на паузу в зависимости от флага `isPlay`.

```js 
const playPauseSound = () => {
  if (isPlay) {
    audio.pause();
    playButton.textContent = '⏸';
  } else {
    audio.play();
    playButton.textContent = '▶'
  }
  isPlay = !isPlay
}
```
`isPlay = !isPlay` изменяет значение `isPlay` на противоположное, когда мы нажимаем на кнопку `play/pause`, чтоб изменялся статус нашего плеера (игарет или на паузе) и функция `playPauseSound` корректно работала.
Теперь при каждом нажатии на кнопку у нас будет либо воспроизводиться либо останавливаться композиция.
Если необходимо по-разному стилизовать кнопку `play` в зависимости от состояния, то можно использовать css-стили и методы  `classList`(c `classList` ты немного знакома)
Метод `classList` предназначен для работы с классами и поддерживается всеми современными браузерами:
- `element.classList.add('class');` - добавляет элементу класс;
- `element.classList.remove('class');` - удаляет класс;
- `element.classList.toggle('class');` - переключает класс: добавляет, если класса нет, и удаляет, если он есть.
Где 'element' - это твой `html` элемент, которому нужно добавить/удалить классы (`playButton` в данном конкретном случае).
  
Далее необходимо найти элементы, которые будут отображать имя исполнителя и название композиции, при помощи `querySelector` и добавить в них необходимый текстовый контент.
```js
const atristName = document.querySelector('.artist');
const soundName = document.querySelector('.sound_name');

artistName.textContent = 'Юлия Александровна';
soundName.textContent = 'Я по уши в тебя влюблен!'
```
Базовая модель плеера у нас готова.

##### Регулятор громкости

Следующим шагом, добавим регулятор громкости в плеер.
Для этого в верстку добавим кнопку для отключения громкости и включения на тот же уровень, что была громкость прежде. Делается это по аналогичному принципу описанному для `play/pause` кнопки:
1) добавить элемент кнопки (в данном случае это элемент `input type="button"`)
2) стилизовать его
3) найти этот элемент при помощи `querySelector`
4) навесить листенер
```js
volumeSwitchButton.addEventListener('click', switchVolume)
```
Функия `switchVolume` будет проверять уровень звука и если звук больше 0, то выключит его, если равен нулю, то установит его уровень на 100%.
```js
const switchVolume = () => {
    if (audio.volume === 0) {
        audio.volume = 1;
        switch_volume.value = '🔊'
    } else {
        audio.volume = 0;
        switch_volume.value = '🔇'
    }
}
```

Далее добавим регулятор громкости. В html для "ползунков" применяется элемент `input type="range"`.
Немного теории о [ползунках(😁)](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range#:~:text=The%20range%20input%20type%20lets,and%20balance%2C%20or%20filter%20controls).
**Необходимо продумать какие аттрибуты и с какими значениями нам необходимы для корректной и красивой работы ползунка.**
Добавим этот элемент в наш верстку и стилизуем согласно дизайну ([несколько примеров стилизации при помощи CSS](https://freefrontend.com/css-range-sliders/)).
Далее находим элемент регулировки в js-файле, с помощью `querySelector` и навешиваем на него листенер, который будет вызываться каждый раз, когда мы перетаскиваем ползунок.
```js
volumeAdjustingRange.addEventListener('input', adjustVolume)
```
Функция `adjustVolume, как говорит ее название, будет регулировать громкость в зависимости от значения ползунка.
```js
const adjustVolume = (e) => {
    const currentVolumeValue = e.target.value
    audio.volume = +currentVolumeValue/100
}
```
В этот раз нам понадобится информация об ивенте и о элементе на котором был вызван этот ивент, поэтому в агрументах функции пропишем переменную `e`, которая будт автоматически к нам приходить из `addEventListener`. Как видно из кода, через `e` мы обращаемся к элементу ползунка (`target`, который будет ссылаться на наш `input type="range"` элемент) и берем из этого элемента его текущее значение (`value`). Далее присваиваем это значение свойству `value` нашего объекту `audio`. (**Примечание:** в данном случае это значение делилось на 100, т.к. я не задавал ползунку в аттрибутах границы в которых ему можно изменяться, ты же можешь добавить, чтоб он изменялся в пределах 0 - 1, тогда делить на 100 нет необходимости.)


#### Добавление дорожки аудио
Добавление дорожки аудио потребует добавления ряда листенеров на разные события аудио и `input type="range"` элементов.
Сначала добавим блок, который будет содержать в себе подблок со временем воспроизведения и полным временем композиции, а так же подблок с самим элементов трека - в текущей реализации будем использовать `<input type="range" value="0" min="0" step="1" />`, где:
- `value="0"` - текущее значение инпута. Т.к. трек еще не запущен и ползунок трека находится в самом начале(слева), то есть смысл `value` сразу установить на 0;
- `min="0"` - минимально возможное значение инпута, иначе говоря, начальное значение;
- `step="1" - шаг, с которым будет изменяться инпут. В контексте плеера, 1 - семантически будет означать шаг в 1 секунду.
-  аттрибут `max`, который означает максимально возможное значение инпута не устанавливаем, т.к. он будет переменным, в зависимости от длительности композиции. Его мы будем устанавливать в js-файле,  после загрузки аудиозаписи.

После добавления элементов, хранящих в себе значения на **текущее время воспроизведения**, **полное время воспроизведения** и `input type="range"`, и стилизации этих элементов, в файле player.js при помощи `querySelector` найдем эти элементы и присвоим ссылки на них перменным:
```js
const currentTime = document.querySelector('.current_time');
const endTime = document.querySelector('.end_time')
const track = document.querySelector('.track')
```
Для начала вычислим время текущей аудиозаписи и отобразим в соответствующем html-элементе.
Т.к. браузер работает так, что после указания атрибута `audio.src`, ему нужно какое-то время для загрузки мелодии и определения некоторых его свойств, то получить полную длительность аудиозаписи сразу после установки `audio.src` мы не можем. Для решение этой задачи повесим на `audio` листенер с событием `durationchange`, которое сработает, когда аудиозапись загрузится и свйоству `duration` объекта `audio` назначится полное время трека **в секундах**.
```js
audio.addEventListener('durationchange', setSoundFullTime)
```
`setSoundFullTime` - функция, которая должна достать из `audio` длительность аудиозаписи в секундах, преобразовать в нужный формат(например mm:ss) и установить в `endTime` компоненте, а так же задать максимальное значение для инпута(`input type="range"), чтоб инпут подстроился к длине аудиозаписи:
 ```js
 const setSoundFullTime = () => {
    const trackDuration = audio.duration
    const fullTime = getMinuteTimeFormat(trackDuration)
    endTime.textContent = fullTime
    track.max = audio.duration
}
```
В свою очередь функция `getMinuteTimeFormat` - это функция, которая преобразует секунды в строку вида `03:45` например, либо `1:12:43`,  когда запись длится 1 час, 12 минут и 43 секунды.
Пример реализации такой функции: 
```js
const getMinuteTimeFormat = (timeInSeconds) => {
    let hours, minutes, seconds;
        hours = Math.floor(timeInSeconds / 3600)
        minutes = Math.floor((timeInSeconds - hours * 3600) / 60)
        seconds = Math.ceil(timeInSeconds - hours * 3600 - minutes * 60)
    return `${hours ? `${hours}:` : ''}${minutes ? getCorrectFormat(minutes) : '00'}:${getCorrectFormat(seconds)}`
}
```
Функция `getCorrectFormat` просто добавляет `0` перед цифрой, если она меньше 10.
```js
const getCorrectFormat = (number) => {
    return number < 10 ? `0${number}` : number
}
```
Итак, когда аудиозапись загрузится и вызовется функция `setSoundFullTime`, то вычислится и преобразуется в корректный вид время трека и засетается в `textContent` для `endTime`.

Теперь перейдем к определению текущего времени воспроизведения трека.
У объекта `audio`, в арсенале имеется листенер, который срабатывает, когда у аудиозаписи изменяется текущее время воспроизведения, иначе говоря, во время игры аудиозаписи этот листенер срабатывает каждую секунду. Навесим листенер и скажем ему выполнять функцию, которая определит текущее время трека в секундах, преобразует его в удобочитаемый формат, а также изменяет положение ползунка и устанавливает его в позицию, соответствующую текущему времени в секундах:
```js
const calculateCurrentSoundTime = () => {
    const currentSoundTime = getMinuteTimeFormat(audio.currentTime)
    currentTime.textContent = currentSoundTime
    track.value = audio.currentTime
}

audio.addEventListener('timeupdate', calculateCurrentSoundTime)
```
Теперь, когда играет аудиозапись, то каждую секунду будет вызываться функция `calculateCurrentSoundTime` и обновлять текущее время трека и положение ползунка на дорожке аудио.

Окей, отвлекусь на секундочу и скажу, что Вы, уважаемая, Юлия Александровна - самая несравненная, красивая и крышесносная девочка. И единственная и неповторимая кошечка. И у меня слов нет, чтоб выразить как свои чувства к тебе.

Вернемся к вестке. 
Теперь у нас готов почти весь фукнционал плеера. Однако у плееров есть функция перемотки аудиозаписи вперед или назад путем перетягивания ползунка на дорожке воспроизведения. Добавим этот функционал.
Для того, чтоб программа определелила, что мы перетянули ползунок и установили его в каком-то положении и заиграло аудио именно в этом положении, добавим ползунку листенер, который сработает, когда мы зажимаем левой кнопкой мыши ползунок, а потом его отпускаем. Событие называется `mouseup`. Момент срабатывания данного события - когда мы отпускаем ранее зажатую левую клавишу мыши.
```js
track.addEventListener('mouseup', playInSpecificPosition)
```
Функция `playInSpecificPosition` определяет место, куда ты перетянула ползунок и через ивент `e` получает это значение, а далее назначает текущее время трека равное значению полученному из ивента `e`. после вызывает ранее написанную функцию `calculateCurrentSoundTime`, которая так же обновит и отображаемое в плеере текущее время композиции.
```js
const playInSpecificPosition = (e) => {
    audio.currentTime = e.target.value
    calculateCurrentSoundTime()
}
```
Теперь перетягивание ползунка перематывает композицию на то время, которое соответствует положению ползунка дорожки.
Однако у нас все еще есть 1 баг: когда играет песня и ты перетягиваешь ползунок, то ползунок сначала тянется за твоим курсором, а потом возвращается обратно на позицию текущего времени трека.
Так случается, потому что в то время, когда мы перетягиваем ползунок и песня играет, у нас постоянно срабатывает 
`audio.addEventListener('timeupdate', calculateCurrentSoundTime)` и функция `calculateCurrentSoundTime` обновляет положение ползунка в соответствии с воспроизведением мелодии. ЛОгично предположить, что когда мы захватили левой кнопкой мыши ползунок, то этого обновления быть не должно, а когда мы его отпустим, обновление должно возобновиться. 
Для осуществления такой логики введем новую переменную, которая будет называться `isDragg`. Эта переменная - флаг, который будет иметь значение по умолчани `false` и оказывать на то, захвачен ли ползунок левой кнопкой мыши и перетягивается ли он в данный момент. Если `isDragg` будет равен `false`, для программы это значит, что все идет по плану и никто не перетягивает полунок трека. Если же `isDragg === true`, то программа будет останавливать обновление положения ползунка, тем самым не давая ему возвращаться на место, в процессе перетягивания.
```js
let isDragg = false
```
Далее повесим два листенера на ползунок:
1) срабатывание при нажатии и удерживании на ползунке левой кнопки мыши - используется ивент `mousedown`;
2) срабатывание при отпускании левой кнопки мыши - особождение ползунка - используется ивент `mouseup`.
```js
track.addEventListener('mousedown', () => {
    isDragg = true
})

track.addEventListener('mouseup', playInSpecificPosition)
```
Итак, при нажатии и захвате ползунка `isDragg` меняет свое значение на с `false` на `true`. Теперь, когда этот флаг `true` на нужно добавить логику запрета обновления положения ползунка в фунции calculateCurrentSoundTime, ведь именно она за это отвечает в строке `track.value = audio.currentTime`.
Предлагаю сделать так, чтоб положение трека обновлялось всегда при `isDragg === false`, т.е. когда перетягивания нет, все обновляется, когда перетягивание есть и `isDragg === true` с `track.value` ничего не происходит. Обновим функцию `calculateCurrentSoundTime`:
```js
const calculateCurrentSoundTime = () => {
    const currentSoundTime = getMinuteTimeFormat(audio.currentTime)
    currentTime.textContent = currentSoundTime
    if (!isDragg) { track.value = audio.currentTime } // updated
}
```
Теперь у нас появился новый баг. После протягивания ползунка и перемотки композиции ползунок остается на месте. Это происходит из-за того6 что `isDragg` по-прежнему равен `true`  и поледние внесенные изменения не дают обновляться положению ползунка при воспроизведении. Нужно вернуть `isDragg` в первоначальное состояние. Добавим эту логику в функцию `playInSpecificPosition`, т.к. она вызывается при отпускании левой кнопки мыши с ползунка:
const playInSpecificPosition = (e) => {
    audio.currentTime = e.target.value
    calculateCurrentSoundTime()
    isDragg = false
}`

Теперь все работает ожидаемо. Поздравляю, ты на шаг приблизилась к тому, чтоб стать программистом.🥰 😘

